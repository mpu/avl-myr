use std
use bio
use moreds

const NChain = 2
type word    = int
/* type chain   = word[2] */ /* meh, this does not really work as I want */

const term : word = 0

var words  : std.htab(byte[:], word)#
var nextid : word
var wmap   : moreds.avl(word[2], word[:])#
var wtos   : byte[:][:]

/* compare two chain of words */
const ccmp = {a : word[2], b : word[2]
	var i

	for i = 0; i < NChain; i++
		if a[i] < b[i]
			-> `std.Before
		elif a[i] > b[i]
			-> `std.After
		;;
	;;
	-> `std.Equal
}

const addw = {c : word[2], w : word

	match moreds.avlget(wmap, c)
	| `std.Some sl:
		std.slpush(sl, w)
	| `std.None:
		var sl = std.slalloc(0)
		std.slpush(sl, w)
		moreds.avlins(wmap, c, sl)
	;;
}

/* read a word from the standard input, None is returned when nothing can be read */
const readw = {f
	const isword = {c; -> std.isalnum(c) || c == '-' }
	const isterm = {c; -> c == '.' || c == '?' || c == ':' }
	var sb
	var s

	sb = std.mksb()
	while true
		match bio.getc(f)
		| `bio.Ok c:
			if isterm(c)
				std.sbfree(sb)
				-> `std.Some term
			;;
			if isword(c)
				std.sbputc(sb, c)
				break
			;;
		| _:
			std.sbfree(sb)
			-> `std.None
		;;
	;;
	while true
		match bio.peekc(f)
		| `bio.Ok c:
			if isword(c)
				bio.getc(f)
				std.sbputc(sb, c)
			else
				break
			;;
		| _: break
		;;
	;;

	s = std.sbfin(sb)
	std.sbfree(sb)

	match std.htget(words, s)
	| `std.Some n:
		std.slfree(s)
		-> `std.Some n
	| `std.None:
		std.htput(words, s, nextid)
		std.slpush(wtos, s[:])
		-> `std.Some nextid++
	;;
}

const main = {
	var ch : word[2]
	const shift = {w : word
		if w == term
			std.slfill(ch[:NChain], term)
		else
			std.slcp(ch[:NChain-1], ch[1:NChain])
			ch[NChain-1] = w
		;;
	}
	var stdin
	var c
	var next
	var ws

	words = std.mkht(std.slhash, std.sleq)
	wmap = moreds.mkavl(ccmp)
	nextid = 1
	wtos = std.slalloc(0)
	std.slpush(wtos, "TERM"[:])

	c = 1
	stdin = bio.mkfile(0 castto(std.fd), bio.Rd)

	/* step 1, learn */
	shift(term)
	while true
		match readw(stdin)
		| `std.Some w:
			addw(ch, w)
			shift(w)
		| `std.None:
			break
		;;
	;;

	/* step 2, generate random stuff */
	while c-- > 0
		shift(term)
		while true
			match moreds.avlget(wmap, ch)
			| `std.None:
				ws = [term][:]
			| `std.Some ws0:
				ws = ws0
			;;
			next = ws[std.rand(0, ws.len)]
			if next == term
				std.put(".")
				break
			;;
			std.put(" {}", wtos[next])
			shift(next)
		;;
	;;
}
